<!DOCTYPE html>
<html dir="rtl" lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <title>الحل والكود الكامل لبرنامج المزاد السري</title>
</head>

<body>
    <div class="book-page">
        <h1 class="book-title">الحل والكود الكامل لبرنامج المزاد السري</h1>
        <div class="content">
            <p>
                اتمنى انك قمت بالفعل بكتابة كود البرنامج وجئت هنا لكي تتحقق من الحل فقط,
                من المهم جدا عندما تقوم ببناء مشروع كبير ان تقوم بتقسيمه الى اجزاء صغيرة
                ثم تبدأ في حلها واحدة بواحدة وأفضل طريقة لفعل ذلك هي صناعة مخطط
                للبرنامج الذي تريد بناءه
            </p>
            <p>
                وسوف نتبع المخطط الذي اريتك اياه في الدرس السابق لنقوم ببناء مشروع اليوم
            </p>
            <p>
                واول شيء سوف نقوم به هو عمل
                import
                للوغو من ملف
                art.py
                الذي فيه الرسمة الخاصة بالبرنامج ك
                string
                مخزنة في متغير يسمى
                logo
            </p>
            <pre><code>
from art import logo
print(logo)
        </code></pre>
            <p>
                ثانيا سوف نقوم بالسؤال عن اسم عن طريق ال
                input function
                ونخزنها في متغير يسمى
                name
                مثلا
            </p>
            <pre><code>
name = input("What is your name? ")
        </code></pre>
            <p>
                تاليا سوف نقوم بالسؤال عن قيمة المزايدة
            </p>
            <pre><code>
price = int(input("What is your bid? $"))
        </code></pre>
        <p>
            الان سوف نضيف الاسم وقيمة المزايدة في قاموس وقلنا في الدرس السابق ان الاسماء
            هي المفاتيح في القاموس
        </p>
        <pre><code>
bids = {}
bids[name] = price
        </code></pre>
        <p>
            الان علينا ان نسأل هل هناك مزايدون اخرون او لا؟ 
            يمكننا فعل ذلك من خلال وضع الاسطر السابقة ماعدا انشاء قاموس فارغ داخل حلقة 
            while
        </p>
        <p>
            ونضع متغير يخبرنا اذا انتهت المزايدة او لا نسميه مثلا 
            bidding_finished
        </p>
        <pre><code>
bids = {}
bidding_finished = False

while not bidding_finished:
    name = input("What is your name? ")
    price = int(input("What is your bid? $"))
    bids[name] = price
        </code></pre>
        <p>
            هكذا سوف تعمل الحلقة للأبد لذلك نريد طريقة لتوقيفها من خلال سؤال هل هناك
            مزايدون اخرون او لا؟ 
            فاذا كانت الاجابة 
            no 
            نقوم بقلب قيمة 
            bidding_finished
            الى
            True
            وهكذا تنتهي الحلقة 
        </p>
        <pre><code>
bids = {}
bidding_finished = False

while not bidding_finished:
    name = input("What is your name? ")
    price = int(input("What is your bid? $"))
    bids[name] = price
    should_continue = input("Are there any bidders? Type 'yes' or 'no'. ")
    if should_continue == "no":
        bidding_finished = True
        </code></pre>
        <p>
            اما اذا اختار 
            yes 
            فعلينا ان نقوم بمسح الشاشة من خلال منادات الدالة 
            clear
            اذا كنت تستخدم 
            replit 
            او عد الى الدرس السابق لتعرف اي دالة تنادي في حالة انك تستعمل 
            محرر اكواد اخر 
        </p>
        <pre><code>
    if should_continue == "no":
        bidding_finished = True
    elif should_continue == "yes":
        clear()
        </code></pre>
        <p>
            الان عندما يتم اختيار 
            no 
            سوف نخرج من الحلقة ولكن مازال علينا ان ندور حول القاموس ونجد 
            اكبر مزايد ونعلنه هو الفائز
        </p>
        <p>
            لنضعها في دالة خاصة بها ثم نقوم بمناداتها فيما بعد نسميها 
            find_highest_bidder
            وسوف تأخد 
            bidding_record 
            كمدخل وهو القاموس الذي سوف نبحث فيه 
        </p>
        <pre><code>
def find_highest_bidder(bidding_record):    
        </code></pre>
        <p>
            الان سوف نقوم بالدوران في القاموس الخاص بنا باستعمال حلقة 
            for 
        </p>
        <pre><code>
def find_highest_bidder(bidding_record):
    highest_bid = 0
    winner = ""
    for bidder in bidding_record:
    bid_amount = bidding_record[bidder]
    if bid_amount > highest_bid: 
        highest_bid = bid_amount
        winner = bidder
    print(f"The winner is {winner} with a bid of ${highest_bid}")
        </code></pre>
        <p>
            ما يحدث هنا انه في كل مرة نحصل على مفتاح من القاموس من حلقة ال
            for
            نمرره للقاموس لنحصل على قيمة المزايدة ثم خارج الحلقة 
            هناك متغيرات واحد يحمل اسم الفائز الاخر يحمل قيمة المزايدة 
            وفي كل مرة نتحقق اذا كانت قيمة المزايدة الحالية اكبر من التي قبلها 
            في هذه الحالة نغير قيمة المزايدة المخرنة في متغير 
            bid_amount
            وقيمة الفائز الى اسم صاحب اكبر قيمة مزايدة 
            winner
            وفي الاخير نقوم بطبع رسالة نعلن فيها الفائز وقيمة المزايدة الاكبر
        </p>
        <p>
            ثم نقوم بمنادات هذه الدالة عندما يتم اختيار 
            no 
            بعدما قمنا بقلب قيمة 
            bidding_finished
        </p>
        <pre><code>
    if should_continue == "no":
        bidding_finished = True
        find_highest_bidder(bids)
    elif should_continue == "yes":
        clear()
        </code></pre>
        <p>
            الكود كاملا: 
        </p>
        <pre><code>
from replit import clear
from art import logo
print(logo)

bids = {}
bidding_finished = False


def find_highest_bidder(bidding_record):
    highest_bid = 0
    winner = ""
    for bidder in bidding_record:
    bid_amount = bidding_record[bidder]
    if bid_amount > highest_bid: 
        highest_bid = bid_amount
        winner = bidder
    print(f"The winner is {winner} with a bid of ${highest_bid}")


while not bidding_finished:
    name = input("What is your name?: ")
    price = int(input("What is your bid?: $"))
    bids[name] = price
    should_continue = input("Are there any other bidders? Type 'yes or 'no'.\n")
    if should_continue == "no":
        bidding_finished = True
        find_highest_bidder(bids)
    elif should_continue == "yes":
        clear()
        </code></pre>
        </div>
    </div>
</body>

</html>